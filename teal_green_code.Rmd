---
title: "SPPH604: Polypharmacy & Mortality – Reproducible Analyses (MI pooled)"
author: "Teal Green (Alexi, Alex, Ezra)"
date: "`r format(Sys.Date())`"
output:
  html_document:
    df_print: paged
  pdf_document:
    latex_engine: xelatex
    keep_tex: false
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.pos = 'H')
set.seed(604)
```

# Overview

This document loads the cleaned analytic dataset produced by `data_clean.R` and performs our analysis. We follow NHANES best practice: build the **survey design first (on the full dataset)**, apply **eligibility via survey subsetting**, and then conduct analyses. We address missingness in key variables with **multiple imputation (MI)**, and fit and pool **all models across imputations** unless noted.

**Research question.** Among U.S. adults aged 45 years or above in NHANES 2003–2018, are levels of medication use associated with all‑cause mortality?

**PICOT elements**  
**Population (P):** U.S. adults aged 45+ in the 2003–2018 NHANES cycles.  
**Intervention/Exposure (I):** Polypharmacy level by number of medications at interview: No polypharmacy (0 medications), polypharmacy (5–9), hyperpolypharmacy (≥10).  
**Comparator (C):** Low medication use (1–4).  
**Outcome (O):** Time from interview to **all‑cause mortality** (or censoring) using NHANES‑linked mortality files.  
**Timeframe (T):** Up to ~17 years of follow‑up (through 2019 linkage in public files).  
**Confounders (a priori):** Age (RIDAGEYR), sex (RIAGENDR), race/ethnicity (RIDRETH1), education (DMDEDUC2), **income‑to‑poverty ratio (INDFMPIR; imputed via PMM)**, health insurance (HIQ011), comorbidity burden (count and Charlson‑like score), and healthcare utilization (doctor visits; overnight hospital stays). We use survey strata, PSU, and interview weights throughout.

> **Notes:** Our primary categorical exposure uses **1–4 medications as the reference** in regression models, aligning with clinical interpretation of "low polypharmacy" as the baseline. For the spline sensitivity, we display HRs **relative to 0 medications** to visualize the entire dose‑response curve from zero upward. We have expanded covariate adjustment to include insurance status and utilization measures.

## Packages

```{r packages}
library(tidyverse)
library(survey)
library(survival)
library(gtsummary)
library(gt)
library(broom)
library(mice)
library(mitools)
library(naniar)
library(ggplot2)
library(scales)
library(DataExplorer)

options(survey.lonely.psu = "adjust")
```

## Load analytic dataset & survey design

We begin by loading our cleaned dataset and constructing the survey design object that accounts for NHANES' complex sampling structure.

```{r load-data}
# Read the raw analytic dataset produced by data_clean.R
analytic_raw <- readRDS("data/analytic_raw.rds")

# Pool interview weights across 8 cycles (2003–2018)
analytic_raw <- analytic_raw %>% mutate(wtint_pool = wtint2yr / 8)

# Build survey design on the full dataset
dsgn_all <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra,
                      weights = ~wtint_pool, nest = TRUE,
                      data = analytic_raw)

# Eligibility: age >= 45, non-missing survival outcome/time
dsgn_elig <- subset(dsgn_all, !is.na(ridageyr) & ridageyr >= 45 & 
                      !is.na(time_y) & event %in% c(0,1))

# Derive model-ready factors inside the survey design
dsgn_elig <- update(
  dsgn_elig,
  age_years   = ridageyr,
  age_cat     = factor(case_when(
                    ridageyr >= 45 & ridageyr < 65 ~ "45-64",
                    ridageyr >= 65 & ridageyr < 80 ~ "65-79",
                    ridageyr >= 80                 ~ "80 or above"),
                    levels = c("45-64","65-79","80 or above")),
  sex         = sex,
  race_eth    = race_eth,    
  ed_cat      = ed_cat,       
  insured     = insured,       
  rxdcount    = rxdcount,
  poly_cat    = factor(poly_cat, levels = c("1–4","0","5–9","≥10")),  
  comorbidity_n = as.numeric(comorbidity_n),
  cci_score     = as.numeric(cci_score),
  visits_cat    = visits_cat,
  hosp_stays_cat= hosp_stays_cat,
  time_y        = time_y,
  event         = event,
  ucod_leading  = ucod_leading
)

elig_df <- dsgn_elig$variables
glimpse(elig_df)
```

# Missingness review (post‑eligibility)

We inspect **INDFMPIR** and **insured** after eligibility subsetting to assess patterns of missingness.

```{r missingness-review}
miss_vars <- c(
    "indfmpir","insured","age_years","sex","race_eth","ed_cat",
    "comorbidity_n","cci_score","visits_cat","hosp_stays_cat"
)

# Variable-wise missingness summary (counts & %)
elig_df %>%
    miss_var_summary(include = dplyr::all_of(miss_vars))

# Plot mkissingness
plot_missing(elig_df[, miss_vars])

# Cross-tab of missingness indicators vs key predictors (simple MAR diagnostics)
elig_df <- elig_df %>%
  mutate(
    miss_indfmpir = factor(ifelse(is.na(indfmpir), "Missing","Observed")),
    miss_insured  = factor(ifelse(is.na(insured),  "Missing","Observed"))
  )

# Simple logistic models for missingness (MCAR would imply no association)
fit_miss_indf <- glm(I(is.na(indfmpir)) ~ 
                       age_years + sex + race_eth + ed_cat + insured + comorbidity_n + cci_score +
                       visits_cat + hosp_stays_cat,
                     data = elig_df, family = binomial())
fit_miss_ins  <- glm(I(is.na(insured)) ~ 
                       age_years + sex + race_eth + ed_cat + indfmpir + comorbidity_n + cci_score +
                       visits_cat + hosp_stays_cat,
                     data = elig_df, family = binomial())

broom::tidy(fit_miss_indf, exponentiate = TRUE, conf.int = TRUE) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), ~round(., 2))) %>% 
  select(term, estimate, conf.low, conf.high, p.value)

broom::tidy(fit_miss_ins, exponentiate = TRUE, conf.int = TRUE) %>%
    dplyr::mutate(dplyr::across(where(is.numeric), ~round(., 2))) %>% 
  select(term, estimate, conf.low, conf.high, p.value)
```

**Interpretation:** Logistic models of missingness reject MCAR for both INDFMPIR and INSURED. INDFMPIR missingness is strongly patterned by age, race/ethnicity, education, and insurance responses. Insurance missingness also varies with age, race/ethnicity, education, and income. We proceed with MI under the MAR assumption using observed predictors for INDFMPIR. We do not impute insurance and acknowledge that the small residual NA portion may not be ignorable MCAR.

# Multiple imputation (MI) for INDFMPIR (PMM)

We impute **only `indfmpir`** using **predictive mean matching (PMM)** with predictors `ed_cat + age_years + sex + race_eth + insured`. We use **m = 20** imputations and **maxit = 10** iterations.

```{r multiple-imputation}
# Prepare mids data.frame with needed fields
# Convert insured to factor for MI (Yes/No based on non-missing status)
mi_vars <- elig_df %>%
  transmute(
    seqn,
    sddsrvyr,
    ridageyr = age_years,
    riagendr,
    ridreth1,
    wtint2yr,
    sdmvpsu,
    sdmvstra,
    wtint_pool,
    time_y,
    event,
    ucod_leading,
    age_years,
    sex,
    race_eth,
    ed_cat,
    insured = factor(
      case_when(
        insured == "Yes" ~ "Yes", 
        insured == "No"  ~ "No", 
        TRUE ~ NA_character_),
      levels = c("No", "Yes")
    ),
    indfmpir,
    rxdcount,
    poly_cat,
    comorbidity_n,
    cci_score,
    visits_cat,
    hosp_stays_cat
  )

# Build empty 'mids' where only indfmpir is imputed
meth <- make.method(mi_vars)
pred <- make.predictorMatrix(mi_vars)

# Only INDFMPIR is imputed via PMM; all others "" (no imputation)
meth[] <- ""
meth["indfmpir"] <- "pmm"

# Predictor set for INDFMPIR
pred[,] <- 0
pred["indfmpir", c("ed_cat","age_years","sex","race_eth","insured")] <- 1

imp <- mice(
  mi_vars,
  m = 20, maxit = 10,
  method = meth,
  predictorMatrix = pred,
  seed = 123,
  printFlag = FALSE
)

# Derive INDFMPIR categories within each completed dataset
cut_pir <- function(x) {
  case_when(
    is.na(x)            ~ NA_character_,
    x < 1               ~ "<1.00 (below poverty)",
    x >= 1 & x < 2      ~ "1.00–1.99",
    x >= 2 & x < 4      ~ "2.00–3.99",
    x >= 4              ~ "≥4.00"
  ) %>% factor(levels = c("<1.00 (below poverty)","1.00–1.99","2.00–3.99","≥4.00"))
}

# Complete to a list of data.frames with derived indfmpir_cat
comp_list <- lapply(1:imp$m, function(i) {
  di <- complete(imp, i)
  di %>% mutate(indfmpir_cat = cut_pir(indfmpir))
})

# Build survey designs for each imputed dataset
design_list <- lapply(comp_list, function(di) {
  svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
            nest = TRUE, data = di)
})

# Helper to get complete-case subset inside each imputed dataset
cc_vars <- c("age_cat","sex","race_eth","ed_cat","indfmpir_cat","insured",
             "poly_cat","comorbidity_n","cci_score","visits_cat","hosp_stays_cat",
             "time_y","event")
design_list <- lapply(design_list, function(dd) {
  dd <- update(dd,
               age_cat = factor(case_when(
                          ridageyr >= 45 & ridageyr < 65 ~ "45-64",
                          ridageyr >= 65 & ridageyr < 80 ~ "65-79",
                          ridageyr >= 80                 ~ "80 or above"),
                          levels = c("45-64","65-79","80 or above")),
               poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10"))
  )
  cc_idx <- complete.cases(dd$variables[, cc_vars])
  subset(dd, cc_idx)
})
```

# Descriptive statistics (MI-completed, imputation #1)

For clarity and reproducibility, we present descriptives using **imputed dataset #1** (fully completed). Continuous variables are **survey‑weighted mean (SD)**; categorical are **unweighted n (%)**. Each table includes an **Overall** column.

```{r descriptives, results='asis'}
d1 <- design_list[[1]]
dat1 <- d1$variables %>%
  mutate(event_f = factor(event, levels = c(0,1), labels = c("Alive/Censored","Deceased")))

cont_vars <- c("rxdcount","comorbidity_n","cci_score")

# ========== BY OUTCOME ==========
n_alive <- sum(dat1$event_f == "Alive/Censored", na.rm = TRUE)
n_deceased <- sum(dat1$event_f == "Deceased", na.rm = TRUE)
n_overall <- nrow(dat1)

tbl_cont_outcome <- tbl_svysummary(
  data = d1, by = event, include = all_of(cont_vars),
  statistic = list(all_continuous() ~ "{mean} ({sd})"), missing = "no",
  label = list(rxdcount ~ "Medication count", comorbidity_n ~ "Number of comorbidities",
               cci_score ~ "Charlson-like comorbidity score")
) %>%
  add_overall() %>%
  modify_header(
    stat_1 ~ paste0("**0**  \nN = ", format(n_alive, big.mark = ",")),
    stat_2 ~ paste0("**1**  \nN = ", format(n_deceased, big.mark = ",")),
    stat_0 ~ paste0("**Overall**  \nN = ", format(n_overall, big.mark = ","))
  ) %>% bold_labels()

tbl_cat_outcome <- tbl_summary(
  data = dat1, by = event_f,
  include = all_of(intersect(c("poly_cat","age_cat","sex","race_eth","ed_cat",
                  "indfmpir_cat","insured","visits_cat","hosp_stays_cat"), names(dat1))),
  type = list(all_categorical() ~ "categorical"),
  statistic = list(all_categorical() ~ "{n} ({p}%)"), missing = "no",
  label = list(poly_cat ~ "Polypharmacy (ref = 1–4)", age_cat ~ "Age group",
               sex ~ "Sex", race_eth ~ "Race/ethnicity", ed_cat ~ "Education",
               indfmpir_cat ~ "Income-to-poverty ratio", insured ~ "Insurance coverage",
               visits_cat ~ "Doctor visits in past year", hosp_stays_cat ~ "Hospital stays in past year")
) %>%
  add_overall() %>%
  modify_header(
    stat_1 ~ paste0("**Alive/Censored**  \nN = ", format(n_alive, big.mark = ",")),
    stat_2 ~ paste0("**Deceased**  \nN = ", format(n_deceased, big.mark = ",")),
    stat_0 ~ paste0("**Overall**  \nN = ", format(n_overall, big.mark = ","))
  ) %>% bold_labels()

tbl_outcome_merged <- tbl_stack(tbls = list(tbl_cont_outcome, tbl_cat_outcome)) %>%
  modify_caption("**Descriptive statistics by outcome (imputation #1)**") %>%
  modify_footnote(update = all_stat_cols() ~
      "N represents unweighted sample size. Continuous variables are summarized with survey-weighted mean (SD). Categorical variables are summarized with unweighted n (column %)."
  ) %>% bold_labels()

as_gt(tbl_outcome_merged)

# ========== BY EXPOSURE ==========
dat1 <- dat1 %>% mutate(poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10")))
n_by_poly <- table(dat1$poly_cat)
poly_levels <- levels(dat1$poly_cat)

tbl_cont_exposure <- tbl_svysummary(
  data = d1, by = poly_cat, include = all_of(cont_vars),
  statistic = list(all_continuous() ~ "{mean} ({sd})"), missing = "no",
  label = list(rxdcount ~ "Medication count", comorbidity_n ~ "Number of comorbidities",
               cci_score ~ "Charlson-like comorbidity score")
) %>% add_overall() %>% bold_labels()

for (i in seq_along(poly_levels)) {
  tbl_cont_exposure <- tbl_cont_exposure %>%
    modify_header(!!paste0("stat_", i) := paste0("**", poly_levels[i], "**  \nN = ", 
                                      format(n_by_poly[poly_levels[i]], big.mark = ",")))
}
tbl_cont_exposure <- tbl_cont_exposure %>%
  modify_header(stat_0 ~ paste0("**Overall**  \nN = ", format(n_overall, big.mark = ",")))

tbl_cat_exposure <- tbl_summary(
  data = dat1, by = poly_cat,
  include = all_of(intersect(c("event_f","age_cat","sex","race_eth","ed_cat",
                  "indfmpir_cat","insured","visits_cat","hosp_stays_cat"), names(dat1))),
  type = list(all_categorical() ~ "categorical"),
  statistic = list(all_categorical() ~ "{n} ({p}%)"), missing = "no",
  label = list(event_f ~ "Mortality status", age_cat ~ "Age group", sex ~ "Sex",
               race_eth ~ "Race/ethnicity", ed_cat ~ "Education",
               indfmpir_cat ~ "Income-to-poverty ratio", insured ~ "Insurance coverage",
               visits_cat ~ "Doctor visits in past year", hosp_stays_cat ~ "Hospital stays in past year")
) %>% add_overall(last = TRUE) %>% bold_labels()

for (i in seq_along(poly_levels)) {
  tbl_cat_exposure <- tbl_cat_exposure %>%
    modify_header(!!paste0("stat_", i) := paste0("**", poly_levels[i], "**  \nN = ", 
                                      format(n_by_poly[poly_levels[i]], big.mark = ",")))
}
tbl_cat_exposure <- tbl_cat_exposure %>%
  modify_header(stat_0 ~ paste0("**Overall**  \nN = ", format(n_overall, big.mark = ",")))

tbl_exposure_merged <- tbl_stack(tbls = list(tbl_cont_exposure, tbl_cat_exposure)) %>%
  modify_caption("**Descriptive statistics by exposure (polypharmacy)**") %>%
  modify_footnote(update = all_stat_cols() ~
      "N represents unweighted sample size. Continuous variables are survey-weighted; categorical variables are unweighted."
  ) %>% bold_labels()

as_gt(tbl_exposure_merged)
```

\newpage

# Kaplan–Meier curves by polypharmacy + log-rank test

We present a weighted Kaplan-Meier survival curves stratified by polypharmacy category to visualize crude survival patterns over follow-up time.

```{r km-curves, fig.width=8, fig.height=6, fig.cap="Kaplan-Meier survival curves by polypharmacy category"}
# ---- Survey-weighted Kaplan–Meier by polypharmacy (full time; no SE/CI) -----

# Complete imputation #1 for descriptive plots 
di1 <- mice::complete(imp, 1) %>%
  dplyr::mutate(
    poly_cat = factor(poly_cat, levels = c("0", "1–4", "5–9", "≥10"))
  )

# Survey design (pooled interview weights)
dd1 <- svydesign(
  ids     = ~ sdmvpsu,
  strata  = ~ sdmvstra,
  weights = ~ wtint_pool,
  nest    = TRUE,
  data    = di1
)

# One stratified svykm() call over full follow-up (no SE, no CI)
km_fit <- svykm(
  survival::Surv(time_y, event) ~ poly_cat,
  design = dd1,
  se = FALSE, ci = FALSE
)

# Tidy the list of curves for ggplot
km_df <- purrr::imap_dfr(km_fit, function(fit, grp) {
  tibble::tibble(
    time     = fit$time,
    surv     = fit$surv,
    poly_cat = grp
  )
})

# Plot (weighted KM curves)
ggplot2::ggplot(km_df, ggplot2::aes(x = time, y = surv, color = poly_cat)) +
  ggplot2::geom_step(linewidth = 0.9) +
  ggplot2::scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    limits = c(0, 1)
  ) +
  ggplot2::labs(
    title = "Survey-weighted Kaplan–Meier survival by medication category",
    x = "Years since interview",
    y = "Survival probability",
    color = "Polypharmacy"
  ) +
  ggplot2::theme_minimal(base_size = 12) +
  ggplot2::theme(
    legend.position = "right",
    panel.grid.minor = ggplot2::element_blank()
  )

# -------------------------- Design-based log-rank tests ------------------------

if ("svylogrank" %in% getNamespaceExports("survey")) {
  lr_test <- svylogrank(survival::Surv(time_y, event) ~ poly_cat, design = dd1)
  omni_tbl <- tibble::tibble(
    test      = "Design-based log-rank (svylogrank)",
    statistic = unname(lr_test$statistic),
    df        = lr_test$parameter,
    p_value   = lr_test$p.value
  )
} else {
  # Omnibus design-based test via Cox + Rao–Scott (regTermTest)
  fit_lr  <- svycoxph(survival::Surv(time_y, event) ~ poly_cat, design = dd1)
  omnibus <- regTermTest(fit_lr, ~ poly_cat)
  omni_tbl <- tibble::tibble(
    test      = "Design-based log-rank (Cox/regTermTest)",
    statistic = unname(omnibus$Ftest),
    df_num    = omnibus$df[1],
    df_den    = omnibus$df[2],
    p_value   = omnibus$p
  )
}

knitr::kable(
  omni_tbl,
  digits = 4,
  caption = "Omnibus design-based log-rank test across medication-use categories"
)

# Pairwise design-based comparisons (2-group Cox per contrast with Holm adjust)
lvls <- levels(di1$poly_cat)
pairs <- utils::combn(lvls, 2, simplify = FALSE)

sink(tempfile())
pair_tbl <- purrr::map_dfr(pairs, function(pr) {
  dsub <- subset(dd1, poly_cat %in% pr)
  # Relevel to ensure the first element of the pair is the reference
  dsub <- update(dsub, poly2 = factor(poly_cat, levels = pr))
  f2   <- svycoxph(survival::Surv(time_y, event) ~ poly2, design = dsub)

  cs <- summary(f2)$coefficients
  p  <- if (!is.null(cs) && nrow(cs) >= 1) {
    if ("Pr(>|z|)" %in% colnames(cs)) cs[1, "Pr(>|z|)"]
    else if ("p" %in% colnames(cs))    cs[1, "p"]
    else NA_real_
  } else {
    NA_real_
  }

  tibble::tibble(
    contrast = paste0(pr[1], " vs ", pr[2]),
    p_value  = as.numeric(p)
  )
}) %>%
  dplyr::mutate(p_value_adj = p.adjust(p_value, method = "holm"))
sink()

knitr::kable(
  pair_tbl,
  digits = 4,
  caption = "Pairwise design-based log-rank (survey-weighted Cox) comparisons with Holm adjustment"
)
```

\newpage

# Cox PH models (MI pooled): crude → basic → full

We fit three Cox proportional hazards models across the **20 imputed datasets** and pool estimates using Rubin's rules. The reference exposure category is **1–4 medications**.

```{r cox-models}
# Helpers to (re)build analysis variables inside each completed dataset
mk_indfmpir_cat <- function(indfmpir) {
    forcats::fct_relevel(dplyr::case_when(
            is.na(indfmpir) ~ NA_character_, indfmpir < 1 ~ "<1.00 (below poverty)",
            indfmpir >= 1 & indfmpir < 2 ~ "1.00–1.99",
            indfmpir >= 2 & indfmpir < 4 ~ "2.00–3.99", indfmpir >= 4 ~ "≥4.00"),
        "<1.00 (below poverty)", "1.00–1.99", "2.00–3.99", "≥4.00")
}

mk_age_cat <- function(ridageyr) {
    factor(dplyr::case_when(
        ridageyr >= 45 & ridageyr < 65 ~ "45-64",
        ridageyr >= 65 & ridageyr < 80 ~ "65-79",
        ridageyr >= 80 ~ "80 or above"), levels = c("45-64","65-79","80 or above"))
}

# CRUDE (poly_cat only; ref = 1–4 meds)
fit_crude <- with(imp, {
  di <- tibble::tibble(
    sdmvpsu, sdmvstra, wtint_pool, time_y, event,
    poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10"))
  )
  dd <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                  nest = TRUE, data = di)
  svycoxph(Surv(time_y, event) ~ poly_cat, design = dd)
})

# BASIC (+ age/sex/race)
fit_basic <- with(imp, {
  di <- tibble::tibble(
    sdmvpsu, sdmvstra, wtint_pool, time_y, event,
    poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10")),
    age_cat  = mk_age_cat(ridageyr),
    sex, race_eth
  )  %>% 
    dplyr::mutate(dplyr::across(where(is.factor), forcats::fct_drop))
  dd <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                  nest = TRUE, data = di)
  svycoxph(Surv(time_y, event) ~ poly_cat + age_cat + sex + race_eth, design = dd)
})

# FULL (+ education, PIR, insurance, comorbidity, CCI, utilization)
fit_full <- with(imp, {
  di <- tibble::tibble(
    sdmvpsu, sdmvstra, wtint_pool, time_y, event,
    poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10")),
    age_cat  = mk_age_cat(ridageyr), sex, race_eth, ed_cat,
    insured  = factor(insured, levels = c("No","Yes")),
    indfmpir, indfmpir_cat = mk_indfmpir_cat(indfmpir),
    comorbidity_n = as.numeric(comorbidity_n),
    cci_score     = as.numeric(cci_score),
    visits_cat, hosp_stays_cat
  ) %>%
    dplyr::mutate(dplyr::across(where(is.factor), forcats::fct_drop))
  dd <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                  nest = TRUE, data = di)
  svycoxph(
    Surv(time_y, event) ~ poly_cat + age_cat + sex + race_eth +
      ed_cat + indfmpir_cat + insured + comorbidity_n + cci_score +
      visits_cat + hosp_stays_cat,
    design = dd
  )
})

# Variable labels
labels_crude <- list(poly_cat ~ "Polypharmacy")
labels_basic <- list(poly_cat ~ "Polypharmacy", age_cat ~ "Age group",
    sex ~ "Sex", race_eth ~ "Race/ethnicity")
labels_full <- list(poly_cat ~ "Polypharmacy", age_cat ~ "Age group",
    sex ~ "Sex", race_eth ~ "Race/ethnicity", ed_cat ~ "Education",
    indfmpir_cat ~ "Income-to-poverty ratio", insured ~ "Insurance coverage",
    comorbidity_n ~ "Number of comorbidities",
    cci_score ~ "Charlson-like comorbidity index",
    visits_cat ~ "Doctor visits in past year", 
    hosp_stays_cat ~ "Hospital stays in past year")

# Create gtsummary tables for each model
sink(tempfile())
tbl_crude <- gtsummary::tbl_regression(fit_crude, exponentiate = TRUE,
    label = labels_crude) %>% gtsummary::bold_labels()
tbl_basic <- gtsummary::tbl_regression(fit_basic, exponentiate = TRUE,
    label = labels_basic) %>% gtsummary::bold_labels()
tbl_full <- gtsummary::tbl_regression(fit_full, exponentiate = TRUE,
    label = labels_full) %>% gtsummary::bold_labels()
sink()

# Merge all three models into one table
tbl_combined <- gtsummary::tbl_merge(
    tbls = list(tbl_crude, tbl_basic, tbl_full),
    tab_spanner = c("**Crude Model**", "**Basic Model**", "**Full Model**")) %>%
    gtsummary::modify_caption("**Survey-weighted Cox proportional hazards models for all-cause mortality**") %>%
    gtsummary::modify_footnote(update = gtsummary::all_stat_cols() ~ 
            "HR = hazard ratio; CI = confidence interval. Models account for complex survey design and multiple imputation. Reference category for polypharmacy is 1–4 medications.") %>%
    gtsummary::bold_labels()

tbl_combined_gt <- gtsummary::as_gt(tbl_combined) %>%
    gt::tab_source_note(gt::md("**Notes.** Crude model: unadjusted. Basic model: adjusted for age, sex, and race/ethnicity. Full model: additionally adjusted for education, income-to-poverty ratio, insurance, comorbidities, and healthcare utilization."))
```

```{r cox-table, results='asis'}
tbl_combined_gt
```

**Interpretation:** The crude model shows the unadjusted associations between polypharmacy categories and mortality risk. The basic model adjusts for demographics (age, sex, race/ethnicity), while the full model additionally adjusts for socioeconomic factors, comorbidities, and healthcare utilization patterns.

\newpage

# Stratification descriptive statistics by 4 therapeutic-class: Antineoplastic agents, CNS agents, cardiovascular agents, and psychotherapeutic agents

We summarize each therapeutic-class cohort (users only), stratified by polypharmacy.
```{r}
# ---- Descriptives by exposure within therapeutic-class user cohorts ----------
# Continuous variables are survey-weighted; categorical variables are unweighted.
# Column headers show UNWEIGHTED N for each exposure level + an Overall column.

# pull the RX class indicators we need from the master (already joined to analytic_raw upstream)
rx_all <- analytic_raw %>%
  dplyr::select(
    seqn,
    rxdcount,
    rx_respiratory,
    rx_cns,
    rx_cardiovascular,
    rx_topical,
    rx_hormone,
    rx_psychotherapeutic,
    rx_metabolic,
    rx_coagulation,
    rx_gastrointestinal,
    rx_antiinfective,
    rx_misc,
    rx_genitourinary,
    rx_immunologic,
    rx_nutrition,
    rx_antineoplastic,
    rx_biological,
    rx_alternative,
    rx_radiologic,
    rx_plasma_expander
  )

# classes to analyze
rx_targets <- c("rx_antineoplastic", "rx_cns", "rx_cardiovascular", "rx_psychotherapeutic")
rx_targets <- intersect(rx_targets, names(rx_all))

rx_pretty <- c(
  rx_antineoplastic    = "Antineoplastic agents",
  rx_cns               = "CNS agents",
  rx_cardiovascular    = "Cardiovascular agents",
  rx_psychotherapeutic = "Psychotherapeutic agents"
)

# labels reused
lbl_cont <- list(
  rxdcount        ~ "Medication count",
  comorbidity_n   ~ "Number of comorbidities",
  cci_score       ~ "Charlson-like comorbidity score"
)
lbl_cat <- list(
  event_f        ~ "Mortality status",
  age_cat        ~ "Age group",
  sex            ~ "Sex",
  race_eth       ~ "Race/ethnicity",
  ed_cat         ~ "Education",
  indfmpir_cat   ~ "Income-to-poverty ratio",
  insured        ~ "Insurance coverage",
  visits_cat     ~ "Doctor visits in past year",
  hosp_stays_cat ~ "Hospital stays in past year"
)

# helpers
mk_indfmpir_cat <- function(indfmpir) {
  forcats::fct_relevel(
    dplyr::case_when(
      is.na(indfmpir)              ~ NA_character_,
      indfmpir < 1                 ~ "<1.00 (below poverty)",
      indfmpir >= 1 & indfmpir < 2 ~ "1.00–1.99",
      indfmpir >= 2 & indfmpir < 4 ~ "2.00–3.99",
      indfmpir >= 4                ~ "≥4.00"
    ),
    "<1.00 (below poverty)", "1.00–1.99", "2.00–3.99", "≥4.00"
  )
}
mk_age_cat <- function(ridageyr) {
  factor(dplyr::case_when(
    ridageyr >= 45 & ridageyr < 65 ~ "45-64",
    ridageyr >= 65 & ridageyr < 80 ~ "65-79",
    ridageyr >= 80                 ~ "80 or above"
  ), levels = c("45-64","65-79","80 or above"))
}
ensure_ref_14 <- function(f) {
  f <- forcats::fct_drop(f)
  if ("1–4" %in% levels(f) && any(f == "1–4")) forcats::fct_relevel(f, "1–4") else f
}

# imputed dataset #1 for descriptives
di1 <- mice::complete(imp, 1)

# builder: ONE class cohort → gtsummary stacked table (exposure-stratified)
build_desc_subsample_exposure <- function(flag) {
  dat_sub <- di1 %>%
    dplyr::mutate(
      class_flag = dplyr::coalesce(as.integer(rx_all[[flag]][match(seqn, rx_all$seqn)]), 0L)
    ) %>%
    dplyr::filter(class_flag == 1L) %>%
    dplyr::mutate(
      poly_cat       = ensure_ref_14(factor(poly_cat, levels = c("1–4","0","5–9","≥10"))),
      age_cat        = mk_age_cat(ridageyr),
      indfmpir_cat   = mk_indfmpir_cat(indfmpir),
      event_f        = factor(event, levels = c(0,1), labels = c("Alive/Censored","Deceased")),
      rxdcount       = as.numeric(rxdcount),
      comorbidity_n  = as.numeric(comorbidity_n),
      cci_score      = as.numeric(cci_score)
    )

  # unweighted N for headers
  n_overall   <- nrow(dat_sub)
  poly_levels <- levels(dat_sub$poly_cat)
  n_by_poly   <- table(dat_sub$poly_cat)

  # survey design
  d_sub <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                     nest = TRUE, data = dat_sub)

  cont_vars <- c("rxdcount","comorbidity_n","cci_score")

  # Continuous (survey-weighted), by poly_cat
  tbl_cont <- tbl_svysummary(
    data       = d_sub,
    by         = poly_cat,
    include    = all_of(intersect(cont_vars, names(d_sub$variables))),
    statistic  = list(all_continuous() ~ "{mean} ({sd})"),
    missing    = "no",
    label      = lbl_cont
  ) %>%
    add_overall() %>%
    bold_labels()

  for (i in seq_along(poly_levels)) {
    tbl_cont <- tbl_cont %>%
      modify_header(
        !!paste0("stat_", i) := paste0("**", poly_levels[i], "**  \nN = ",
                                       format(n_by_poly[poly_levels[i]], big.mark = ","))
      )
  }
  tbl_cont <- tbl_cont %>%
    modify_header(
      stat_0 ~ paste0("**Overall**  \nN = ", format(n_overall, big.mark = ","))
    )

  # Categorical (unweighted), by poly_cat
  tbl_cat <- tbl_summary(
    data       = dat_sub,
    by         = poly_cat,
    include    = all_of(intersect(
      c("event_f","age_cat","sex","race_eth","ed_cat",
        "indfmpir_cat","insured","visits_cat","hosp_stays_cat"),
      names(dat_sub)
    )),
    type       = list(all_categorical() ~ "categorical"),
    statistic  = list(all_categorical() ~ "{n} ({p}%)"),
    missing    = "no",
    label      = lbl_cat
  ) %>%
    add_overall(last = TRUE) %>%
    bold_labels()

  for (i in seq_along(poly_levels)) {
    tbl_cat <- tbl_cat %>%
      modify_header(
        !!paste0("stat_", i) := paste0("**", poly_levels[i], "**  \nN = ",
                                       format(n_by_poly[poly_levels[i]], big.mark = ","))
      )
  }
  tbl_cat <- tbl_cat %>%
    modify_header(
      stat_0 ~ paste0("**Overall**  \nN = ", format(n_overall, big.mark = ","))
    )

  tbl_stack(
    tbls = list(tbl_cont, tbl_cat)
  ) %>%
    modify_caption(paste0("**Descriptive statistics by exposure — ",
                          rx_pretty[flag], " users (imputation #1)**")) %>%
    modify_footnote(
      update = all_stat_cols() ~
        "N represents unweighted sample size. Continuous variables are summarized with survey-weighted mean (SD). Categorical variables are summarized with unweighted n (column %)."
    ) %>%
    bold_labels()
}

# build all four tables
desc_tables_sub_exposure <- purrr::map(rx_targets, build_desc_subsample_exposure)
names(desc_tables_sub_exposure) <- rx_targets

# Each table will print in place, in order:
desc_tables_sub_exposure[[1]]
desc_tables_sub_exposure[[2]]
desc_tables_sub_exposure[[3]]
desc_tables_sub_exposure[[4]]
```

\newpage

# Stratification models by therapeutic-class

We fit the *full* Cox model in each therapeutic-class cohort (users only), across 20 imputations, and present pooled (Rubin's rules) results in polished tables.
```{r}
# ---- Full models in therapeutic-class user sub-samples (MI-pooled) -----------

# classes to analyze
rx_targets <- c("rx_antineoplastic", "rx_cns", "rx_cardiovascular", "rx_psychotherapeutic")
rx_targets <- intersect(rx_targets, names(rx_all))

rx_pretty <- c(
  rx_antineoplastic    = "Antineoplastic agents",
  rx_cns               = "CNS agents",
  rx_cardiovascular    = "Cardiovascular agents",
  rx_psychotherapeutic = "Psychotherapeutic agents"
)

labels_full <- list(
  poly_cat       ~ "Polypharmacy",
  age_cat        ~ "Age group",
  sex            ~ "Sex",
  race_eth       ~ "Race/ethnicity",
  ed_cat         ~ "Education",
  indfmpir_cat   ~ "Income-to-poverty ratio",
  insured        ~ "Insurance coverage",
  comorbidity_n  ~ "Number of comorbidities",
  cci_score      ~ "Charlson-like comorbidity index",
  visits_cat     ~ "Doctor visits in past year",
  hosp_stays_cat ~ "Hospital stays in past year"
)

mk_indfmpir_cat <- function(indfmpir) {
  forcats::fct_relevel(
    dplyr::case_when(
      is.na(indfmpir)              ~ NA_character_,
      indfmpir < 1                 ~ "<1.00 (below poverty)",
      indfmpir >= 1 & indfmpir < 2 ~ "1.00–1.99",
      indfmpir >= 2 & indfmpir < 4 ~ "2.00–3.99",
      indfmpir >= 4                ~ "≥4.00"
    ),
    "<1.00 (below poverty)", "1.00–1.99", "2.00–3.99", "≥4.00"
  )
}
mk_age_cat <- function(ridageyr) {
  factor(dplyr::case_when(
    ridageyr >= 45 & ridageyr < 65 ~ "45-64",
    ridageyr >= 65 & ridageyr < 80 ~ "65-79",
    ridageyr >= 80                 ~ "80 or above"
  ), levels = c("45-64","65-79","80 or above"))
}
ensure_ref_14 <- function(f) {
  f <- forcats::fct_drop(f)
  if ("1–4" %in% levels(f) && any(f == "1–4")) forcats::fct_relevel(f, "1–4") else f
}

# Fit one full model per class among users (flag == 1) across imputations
fit_full_subsample <- function(flag) {
  # NOTE: use base::with so the S3 method with.mids is used
  with(imp, {
    di <- tibble::tibble(
      seqn, sdmvpsu, sdmvstra, wtint_pool,
      time_y, event, ridageyr, sex, race_eth, ed_cat, insured,
      comorbidity_n = as.numeric(comorbidity_n),
      cci_score     = as.numeric(cci_score),
      rxdcount      = as.numeric(rxdcount),
      visits_cat, hosp_stays_cat,
      poly_cat, indfmpir
    )

    # add class flag (0/1) & subset to users
    di[[flag]] <- dplyr::coalesce(as.integer(rx_all[[flag]][match(di$seqn, rx_all$seqn)]), 0L)
    di <- dplyr::filter(di, .data[[flag]] == 1L)

    # drop '0 meds' level if present; set 1–4 as ref when available
    di <- di %>%
      dplyr::mutate(
        poly_cat       = ensure_ref_14(factor(poly_cat, levels = c("1–4","0","5–9","≥10"))),
        age_cat        = mk_age_cat(ridageyr),
        indfmpir_cat   = mk_indfmpir_cat(indfmpir),
        sex            = forcats::fct_drop(sex),
        race_eth       = forcats::fct_drop(race_eth),
        ed_cat         = forcats::fct_drop(ed_cat),
        indfmpir_cat   = forcats::fct_drop(indfmpir_cat),
        insured        = forcats::fct_drop(insured),
        visits_cat     = forcats::fct_drop(visits_cat),
        hosp_stays_cat = forcats::fct_drop(hosp_stays_cat)
      )

    # survey design
    invisible(utils::capture.output(
      dd <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                              nest = TRUE, data = di)
    ))

    svycoxph(
      Surv(time_y, event) ~ poly_cat + age_cat + sex + race_eth +
        ed_cat + indfmpir_cat + insured + comorbidity_n + cci_score +
        visits_cat + hosp_stays_cat,
      design = dd
    )
  })
}

# pool → tidy (HR) 
tidy_mipo_for_gts <- function(fits_mira, exponentiate = TRUE) {
  po <- mice::pool(fits_mira)
  sm <- summary(po, conf.int = TRUE, conf.level = 0.95)
  if (!"conf.low" %in% names(sm) && "2.5 %" %in% names(sm)) {
    sm <- dplyr::rename(sm, conf.low = `2.5 %`, conf.high = `97.5 %`)
  }
  pcol <- intersect(c("p.value", "Pr(>|t|)"), names(sm))
  sm$p.value <- if (length(pcol) == 0) NA_real_ else sm[[pcol[1]]]
  if (exponentiate) {
    sm <- dplyr::mutate(sm,
      estimate = exp(estimate),
      conf.low = exp(conf.low),
      conf.high = exp(conf.high)
    )
  }
  dplyr::select(sm, term, estimate, conf.low, conf.high, p.value)
}

tbl_from_mira <- function(fits_mira, title, labels) {
  sm <- tidy_mipo_for_gts(fits_mira, TRUE)
  placeholder <- fits_mira$analyses[[1]]
  gtsummary::tbl_regression(
    x = placeholder,
    exponentiate = TRUE,
    label = labels,
    tidy_fun = function(...) sm
  ) %>%
    gtsummary::modify_header(label ~ paste0("**", title, "**")) %>%
    gtsummary::bold_labels()
}

# Fit all four class-specific models
fits_sub <-suppressWarnings(purrr::map(rx_targets, fit_full_subsample))
names(fits_sub) <- rx_targets

sink(tempfile())
# Build polished gtsummary tables
tbls_sub <- purrr::imap(
  fits_sub,
  ~ tbl_from_mira(.x, paste0("Full model among ", rx_pretty[.y]), labels_full)
)

sink()

# each will render in place
tbls_sub[[1]]
tbls_sub[[2]]
tbls_sub[[3]]
tbls_sub[[4]]
```

\newpage

# Sensitivity 1: Continuous exposure (spline)

We fit `svycoxph` with a natural cubic spline for `rxdcount` (knots at 5 & 10 medications), pool **coefficients & covariance** across imputations, then use the **delta method** to plot HRs and 95% CIs **relative to 0 medications** for a **survey‑weighted reference profile** (modes/medians).

```{r spline-model, fig.width=8, fig.height=6, fig.cap="Adjusted hazard ratio vs medication count (MI pooled spline model)"}
# ---- Spline sensitivity (MI-pooled) + non-linearity test + collinearity check ----

# 1) Fit the spline model on each imputed survey design (no poly_cat update needed)
fit_list <- lapply(design_list, function(dd) {
  # keep only the insured relevel (used in the model)
  dd <- update(dd, insured = factor(insured, levels = c("No", "Yes")))
  svycoxph(
    Surv(time_y, event) ~ splines::ns(rxdcount, knots = c(5, 10)) +
      age_cat + sex + race_eth + ed_cat + indfmpir_cat + insured +
      comorbidity_n + cci_score + visits_cat + hosp_stays_cat,
    design = dd
  )
})

# Pool coefficients & vcovs across imputations
coefs <- lapply(fit_list, coef)
vcovs <- lapply(fit_list, vcov)
mi_pool <- mitools::MIcombine(coefs, vcovs)
beta    <- mi_pool$coefficients
V       <- mi_pool$variance
coef_nm <- names(beta)

# 2) Build a reference profile from imputation #1 (survey-weighted medians/modes)
d1 <- design_list[[1]]

svy_median <- function(des, var) {
  q <- svyquantile(as.formula(paste0("~", var)), des, quantiles = 0.5, na.rm = TRUE, ci = FALSE)
  as.numeric(coef(q))
}
svy_mode <- function(des, var) {
  tb <- svytable(as.formula(paste0("~", var)), des)
  nm <- names(tb); nm[which.max(as.numeric(tb))]
}

dat1 <- d1$variables
ref_age_cat_val   <- svy_mode(d1, "age_cat")
ref_sex_val       <- svy_mode(d1, "sex")
ref_race_val      <- svy_mode(d1, "race_eth")
ref_ed_val        <- svy_mode(d1, "ed_cat")
ref_pir_cat_val   <- svy_mode(d1, "indfmpir_cat")
ref_insured_val   <- svy_mode(d1, "insured")
ref_visits_val    <- svy_mode(d1, "visits_cat")
ref_hosp_stays_val<- svy_mode(d1, "hosp_stays_cat")
ref_comorb_n      <- svy_median(d1, "comorbidity_n")
ref_cci           <- svy_median(d1, "cci_score")

# 3) Prediction grid: 0..25 medications at the reference covariate profile
pred_grid_base <- tibble::tibble(
  rxdcount      = 0,
  age_cat       = factor(ref_age_cat_val,   levels = levels(dat1$age_cat)),
  sex           = factor(ref_sex_val,       levels = levels(dat1$sex)),
  race_eth      = factor(ref_race_val,      levels = levels(dat1$race_eth)),
  ed_cat        = factor(ref_ed_val,        levels = levels(dat1$ed_cat)),
  indfmpir_cat  = factor(ref_pir_cat_val,   levels = levels(dat1$indfmpir_cat)),
  insured       = factor(ref_insured_val,   levels = levels(dat1$insured)),
  comorbidity_n = ref_comorb_n,
  cci_score     = ref_cci,
  visits_cat    = factor(ref_visits_val,    levels = levels(dat1$visits_cat)),
  hosp_stays_cat= factor(ref_hosp_stays_val,levels = levels(dat1$hosp_stays_cat))
)

pred_grid <- pred_grid_base |>
  dplyr::slice(rep(1, 26)) |>
  dplyr::mutate(rxdcount = 0:25)

# 4) Model matrix from the pooled spline model, ensure column alignment
TT_full <- terms(fit_list[[1]])
TT_noy  <- delete.response(TT_full)
mf_grid <- model.frame(TT_noy, data = pred_grid,
                       xlev = fit_list[[1]]$xlevels, na.action = na.pass)
X <- model.matrix(TT_noy, mf_grid)
X <- X[, coef_nm, drop = FALSE]

# HRs relative to 0 medications on the reference profile
X_ref  <- X[1, , drop = FALSE]
Delta  <- X - matrix(X_ref, nrow = nrow(X), ncol = ncol(X), byrow = TRUE)
lp     <- as.vector(Delta %*% beta)
se_lp  <- sqrt(pmax(0, rowSums((Delta %*% V) * Delta)))

pred_df <- pred_grid |>
  dplyr::mutate(
    HR  = exp(lp),
    LCL = exp(lp - 1.96 * se_lp),
    UCL = exp(lp + 1.96 * se_lp)
  )

# 5) Plot: MI-pooled adjusted HR vs medication count (spline with knots 5 & 10)
ggplot(pred_df, aes(x = rxdcount, y = HR)) +
  geom_ribbon(aes(ymin = LCL, ymax = UCL), alpha = 0.2) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = 1, linetype = 2) +
  labs(
    title    = "Adjusted hazard ratio vs medication count (MI pooled)",
    subtitle = "Natural cubic spline with knots at 5 and 10",
    x = "Medication count",
    y = "Hazard Ratio (95% CI)"
  ) +
  scale_y_continuous(trans = "log10", breaks = c(0.5, 1, 2, 3, 5, 10)) +
  theme_minimal(base_size = 12) +
  theme(plot.title = element_text(face = "bold"),
        panel.grid.minor = element_blank())

# ------------------------------ Diagnostics -----------------------------------

# (A) Wald test of non-linearity: test curvature terms = 0 after pooling
# Build curvature-only basis (orthogonal to linear rxdcount), df=2 with knots at 5 & 10
make_curvature_basis <- function(x, knots = c(5, 10), boundary = NULL) {
  x <- as.numeric(x)
  if (is.null(boundary)) boundary <- range(x, na.rm = TRUE)
  B <- splines::ns(x, knots = knots, Boundary.knots = boundary, intercept = FALSE)  # 3 cols
  Xlin <- matrix(x, ncol = 1)
  proj <- Xlin %*% solve(crossprod(Xlin), crossprod(Xlin, as.matrix(B)))
  R <- as.matrix(B) - proj
  colnames(R) <- paste0("spl2_", seq_len(ncol(R)))  # typically 2 curvature cols when df=3
  as.data.frame(R)
}

# Fit linear + curvature model on each imputed dataset, then pool and test
fits_curv <- lapply(design_list, function(dd) {
  dat <- dd$variables
  curv <- make_curvature_basis(dat$rxdcount, knots = c(5, 10))
  dat2 <- cbind(dat, curv)
  dd2 <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                   nest = TRUE, data = dat2)
  svycoxph(
    Surv(time_y, event) ~ rxdcount + spl2_1 + spl2_2 +
      age_cat + sex + race_eth + ed_cat + indfmpir_cat + insured +
      comorbidity_n + cci_score + visits_cat + hosp_stays_cat,
    design = dd2
  )
})

coefs_c <- lapply(fits_curv, coef)
vcovs_c <- lapply(fits_curv, vcov)
mi_c    <- mitools::MIcombine(coefs_c, vcovs_c)

# Wald test H0: spl2_1 = spl2_2 = 0 (no curvature; i.e., linear effect is adequate)
beta_c <- coef(mi_c); V_c <- vcov(mi_c)
keep   <- names(beta_c) %in% c("spl2_1", "spl2_2")
C      <- diag(sum(keep))
colnames(C) <- names(beta_c)[keep]; rownames(C) <- colnames(C)
# align C to the full parameter vector
C_full <- matrix(0, nrow = nrow(C), ncol = length(beta_c),
                 dimnames = list(rownames(C), names(beta_c)))
C_full[, keep] <- C

W   <- as.numeric(t(C_full %*% beta_c) %*% solve(C_full %*% V_c %*% t(C_full)) %*% (C_full %*% beta_c))
dfW <- nrow(C_full)
pW  <- pchisq(W, df = dfW, lower.tail = FALSE)

cat("\nWald test of non-linearity (curvature terms = 0): ",
    "Chi-square = ", round(W, 2), " on ", dfW, " df; p = ", signif(pW, 3), "\n", sep = "")

# (B) Multicollinearity: weighted (G)VIFs for the same predictor set (imputation #1)
  di1 <- design_list[[1]]$variables
  curv1 <- make_curvature_basis(di1$rxdcount, knots = c(5, 10))
  di1c  <- cbind(di1, curv1)

  # Dummy weighted linear model (response is irrelevant for VIF)
  vif_fit <- lm(
    rnorm(nrow(di1c)) ~ rxdcount + spl2_1 + spl2_2 +
      age_cat + sex + race_eth + ed_cat + indfmpir_cat + insured +
      comorbidity_n + cci_score + visits_cat + hosp_stays_cat,
    data = di1c,
    weights = wtint_pool
  )

  gv <- car::vif(vif_fit)  # GVIF for multi-df factors; VIF for 1-df terms

  gv_tbl <- if (is.matrix(gv)) {
    tibble::tibble(term = rownames(gv),
                   GVIF = gv[, "GVIF"],
                   Df   = gv[, "Df"],
                   adj_GVIF = gv[, "GVIF"]^(1/(2*gv[, "Df"])))
  } else {
    tibble::tibble(term = names(gv), VIF = as.numeric(gv))
  }

  cat("\nWeighted (G)VIFs for spline model predictors (imputation #1):\n")
  print(gv_tbl)
  cat("Rule of thumb: VIF > 5 (or adjusted GVIF > ~2–3) may indicate concerning collinearity.\n")
```

**Interpretation:** This spline model allows us to examine the dose-response relationship between medication count and mortality risk continuously. The natural cubic spline with knots at 5 and 10 medications provides flexibility to capture non-linear patterns while maintaining smoothness.

\newpage

# Sensitivity 2: Restrict to multimorbidity (comorbidity_n ≥ 2)

We repeat our full model restricting the analysis to individuals with multimorbidity (≥2 comorbidities) to assess whether the polypharmacy-mortality association persists in this high-risk subgroup.

```{r sensitivity-multimorbidity}
fit_multi <- with(imp, {
  di <- tibble::tibble(
    sdmvpsu, sdmvstra, wtint_pool, time_y, event, ridageyr,
    poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10")),
    age_cat = factor(case_when(
      ridageyr >= 45 & ridageyr < 65 ~ "45-64",
      ridageyr >= 65 & ridageyr < 80 ~ "65-79",
      ridageyr >= 80 ~ "80 or above"), levels = c("45-64","65-79","80 or above")),
    sex, race_eth, ed_cat,
    insured = factor(insured, levels = c("No", "Yes")),
    indfmpir, indfmpir_cat = mk_indfmpir_cat(indfmpir),
    comorbidity_n = as.numeric(comorbidity_n),
    cci_score = as.numeric(cci_score),
    visits_cat, hosp_stays_cat
  ) %>%
    filter(comorbidity_n >= 2) %>%
    dplyr::mutate(dplyr::across(where(is.factor), forcats::fct_drop))
  
  dd <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                     nest = TRUE, data = di)
  svycoxph(Surv(time_y, event) ~ poly_cat + age_cat + sex + race_eth +
              ed_cat + indfmpir_cat + insured + comorbidity_n + cci_score +
              visits_cat + hosp_stays_cat, design = dd)
})

sink(tempfile())
tbl_multi <- gtsummary::tbl_regression(
    fit_multi, exponentiate = TRUE, label = labels_full) %>%
    gtsummary::modify_caption("**Sensitivity analysis: Restricted to multimorbidity (≥2 comorbidities)**") %>%
    gtsummary::bold_labels()
sink()
```

```{r sensitivity-multi-table, results='asis'}
as_gt(tbl_multi)
```

**Interpretation:** This sensitivity analysis examines whether our findings hold among those with multimorbidity, who represent a clinically important subgroup with greater healthcare needs and medication burden.

\newpage

# Sensitivity 3: Exclude external‑cause deaths (ucod_leading 4 or 10)

We repeat the full model after **excluding deaths due to external causes** (e.g., injuries or accidents), operationalized as `ucod_leading %in% c(4, 10)` among deaths, to focus on deaths more likely to be related to chronic disease processes.

```{r sensitivity-external}
fit_no_external <- with(imp, {
  di <- tibble::tibble(
    sdmvpsu, sdmvstra, wtint_pool, time_y, event, ucod_leading, ridageyr,
    poly_cat = factor(poly_cat, levels = c("1–4","0","5–9","≥10")),
    age_cat = factor(case_when(
      ridageyr >= 45 & ridageyr < 65 ~ "45-64",
      ridageyr >= 65 & ridageyr < 80 ~ "65-79",
      ridageyr >= 80 ~ "80 or above"), levels = c("45-64","65-79","80 or above")),
    sex, race_eth, ed_cat,
    insured = factor(insured, levels = c("No", "Yes")),
    indfmpir, indfmpir_cat = mk_indfmpir_cat(indfmpir),
    comorbidity_n = as.numeric(comorbidity_n),
    cci_score = as.numeric(cci_score),
    visits_cat, hosp_stays_cat
  ) %>%
    filter(!(event == 1 & ucod_leading %in% c(4, 10))) %>%
    dplyr::mutate(dplyr::across(where(is.factor), forcats::fct_drop))
  
  dd <- svydesign(ids = ~sdmvpsu, strata = ~sdmvstra, weights = ~wtint_pool,
                     nest = TRUE, data = di)
  svycoxph(Surv(time_y, event) ~ poly_cat + age_cat + sex + race_eth +
              ed_cat + indfmpir_cat + insured + comorbidity_n + cci_score +
              visits_cat + hosp_stays_cat, design = dd)
})

sink(tempfile())
tbl_no_external <- gtsummary::tbl_regression(
    fit_no_external, exponentiate = TRUE, label = labels_full) %>%
    gtsummary::modify_caption("**Sensitivity analysis: Excluding external-cause deaths**") %>%
    gtsummary::bold_labels()
sink()
```

```{r sensitivity-external-table, results='asis'}
as_gt(tbl_no_external)
```

**Interpretation:** By excluding external-cause deaths, we can assess whether the polypharmacy-mortality association is driven primarily by disease-related deaths rather than accidental or violence-related deaths.




# Model diagnostics (MI pooled): Full model

We perform diagnostics on the full Cox model fitted via `mice::with()` across 20 imputations, assessing proportional hazards assumption, multicollinearity (GVIF), and model fit.

## 1. Proportional hazards assumption (Schoenfeld residuals, MI-pooled)

For each imputed dataset, we test the PH assumption using scaled Schoenfeld residuals, then pool results.

```{r ph-assumption}
# Extract PH tests from each imputed fit in the mira object
ph_tests_list <- lapply(fit_full$analyses, function(fit_obj) {
  # fit_obj is a svycoxph; cox.zph works on coxph objects
  ph_test <- survival::cox.zph(fit_obj)
  data.frame(
    term = rownames(ph_test$table),
    chisq = ph_test$table[, "chisq"],
    df = ph_test$table[, "df"],
    p_value = ph_test$table[, "p"]
  )
})

# Pool p-values across imputations (simple average)
n_imps <- length(ph_tests_list)
ph_pooled <- ph_tests_list[[1]][, c("term", "df")]
ph_pooled$chisq_mean <- sapply(seq_len(nrow(ph_pooled)), function(i) {
  mean(sapply(ph_tests_list, function(x) x$chisq[i]), na.rm = TRUE)
})
ph_pooled$p_value_mean <- sapply(seq_len(nrow(ph_pooled)), function(i) {
  mean(sapply(ph_tests_list, function(x) x$p_value[i]), na.rm = TRUE)
})
ph_pooled$p_value_sd <- sapply(seq_len(nrow(ph_pooled)), function(i) {
  sd(sapply(ph_tests_list, function(x) x$p_value[i]), na.rm = TRUE)
})

ph_pooled <- ph_pooled %>%
  mutate(
    term = as.character(term),
    assumption_met = ifelse(p_value_mean < 0.05, "⚠ Violated", "✓ Holds"),
    interpretation = ifelse(p_value_mean < 0.05, 
                           "May violate PH; consider stratification or time-varying coef.", 
                           "Proportional hazards assumption appears satisfied")
  ) %>%
  select(term, chisq_mean, df, p_value_mean, p_value_sd, assumption_met)

knitr::kable(
  ph_pooled,
  col.names = c("Variable", "χ² (mean)", "df", "p (mean)", "p (SD across imputations)", "PH Assumption"),
  digits = c(0, 3, 0, 4, 4, 0),
  caption = "Proportional hazards assumption test (pooled across 20 imputations)",
  format = "html"
) %>% kableExtra::kable_styling()
```

**Interpretation:** Tests PH assumption for each covariate. A pooled p-value < 0.05 suggests the assumption may be violated. The SD shows variability across imputations—large SD suggests PH assessment varies by imputation.

## 2. Multicollinearity: GVIF analysis (representative imputation #1)

We assess multicollinearity using generalized variance inflation factors (GVIF) on the first imputation as a representative sample.

```{r multicollinearity-gvif}
# ---- Multicollinearity (GVIF) on imputation #1: auxiliary weighted LM ----

# Build the same analysis frame used in the full model (imp #1)
d1 <- design_list[[1]]$variables %>%
  mutate(
    # ensure identical factor levels & dropped empties as in the Cox model
    poly_cat       = factor(poly_cat, levels = c("1–4","0","5–9","≥10")) %>% forcats::fct_drop(),
    age_cat        = factor(age_cat)        %>% forcats::fct_drop(),
    sex            = factor(sex)            %>% forcats::fct_drop(),
    race_eth       = factor(race_eth)       %>% forcats::fct_drop(),
    ed_cat         = factor(ed_cat)         %>% forcats::fct_drop(),
    indfmpir_cat   = factor(indfmpir_cat)   %>% forcats::fct_drop(),
    insured        = factor(insured, levels = c("No","Yes")) %>% forcats::fct_drop(),
    visits_cat     = factor(visits_cat)     %>% forcats::fct_drop(),
    hosp_stays_cat = factor(hosp_stays_cat) %>% forcats::fct_drop()
  )

# Dummy outcome: VIF uses only the X matrix; outcome choice doesn't matter
set.seed(604)
y_dummy <- rnorm(nrow(d1))

# Auxiliary weighted linear model with the EXACT SAME RHS as the full Cox model
aux_lm <- lm(
  y_dummy ~ poly_cat + age_cat + sex + race_eth + ed_cat + indfmpir_cat +
    insured + comorbidity_n + cci_score + visits_cat + hosp_stays_cat,
  data    = d1,
  weights = wtint_pool
)

# GVIF/GVIF^(1/(2*Df))
gv <- car::vif(aux_lm)

gvif_df <-
  if (is.matrix(gv)) {
    # multi-df terms present
    as.data.frame(gv) %>%
      tibble::rownames_to_column("Variable") %>%
      dplyr::rename(GVIF = GVIF, Df = Df) %>%
      dplyr::mutate(`Adj.GVIF` = GVIF^(1/(2*Df)))
  } else {
    # all 1-df terms
    tibble::tibble(
      Variable = names(gv),
      GVIF     = as.numeric(gv),
      Df       = 1L,
      `Adj.GVIF` = sqrt(GVIF)
    )
  } %>%
  dplyr::mutate(
    Severity = dplyr::case_when(
      `Adj.GVIF` > 5    ~ "🚨 severe",
      `Adj.GVIF` > 2.5  ~ "⚠ high",
      `Adj.GVIF` > 2.0  ~ "~ moderate",
      TRUE              ~ "✓ low"
    )
  )

knitr::kable(
  gvif_df,
  digits  = 3,
  caption = "Adjusted GVIFs (imputation #1); auxiliary weighted linear model with full-model predictors"
) %>%
  kableExtra::kable_styling()
```

**Interpretation:** GVIF > 5 indicates high multicollinearity. Note that categorical variables (age_cat, race_eth, ed_cat) are reported with degrees of freedom. `GVIF^(1/(2*DF))` is a normalized version comparable to univariate VIF; values > 2.5 warrant attention. Moderate correlations among socioeconomic variables (education, income, insurance) are expected.

